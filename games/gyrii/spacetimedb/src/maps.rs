// Map definitions and cube wall layouts

use spacetimedb::{table, ReducerContext, SpacetimeType, Table};
use spacetime_rapier::{Collider, RigidBody, RigidBodyProperties, RigidBodyType, Vec3};

// Import table trait for database access (generated by #[table] macro)
pub use map_wall::map_wall;

// ============================================================================
// MAP TYPES
// ============================================================================

#[derive(Clone, Copy, PartialEq, Eq, Debug, SpacetimeType)]
pub enum MapId {
    Arena,
    Maze,
    Warehouse,
}

// ============================================================================
// MAP WALL TABLE
// ============================================================================

#[table(name = map_wall, public)]
pub struct MapWall {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub lobby_id: u64,
    pub rigid_body_id: u64,
    pub position_x: f32,
    pub position_y: f32,
    pub position_z: f32,
    pub size_x: f32,
    pub size_y: f32,
    pub size_z: f32,
    pub height: i32, // 1 = grenades can arc over, 2 = blocks grenades
}

// ============================================================================
// MAP GENERATION
// ============================================================================

pub fn create_map_geometry(ctx: &ReducerContext, lobby_id: u64, world_id: u64, map_id: MapId) {
    match map_id {
        MapId::Arena => create_arena_map(ctx, lobby_id, world_id),
        MapId::Maze => create_maze_map(ctx, lobby_id, world_id),
        MapId::Warehouse => create_warehouse_map(ctx, lobby_id, world_id),
    }
}

fn create_arena_map(ctx: &ReducerContext, lobby_id: u64, world_id: u64) {
    // Arena boundaries (50x50)
    create_wall(ctx, lobby_id, world_id, Vec3::new(0.0, 1.0, -25.0), Vec3::new(50.0, 2.0, 1.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(0.0, 1.0, 25.0), Vec3::new(50.0, 2.0, 1.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(-25.0, 1.0, 0.0), Vec3::new(1.0, 2.0, 50.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(25.0, 1.0, 0.0), Vec3::new(1.0, 2.0, 50.0), 2);
    
    // Center cross cover (low walls - grenades can arc over)
    create_wall(ctx, lobby_id, world_id, Vec3::new(0.0, 0.5, 0.0), Vec3::new(8.0, 1.0, 2.0), 1);
    create_wall(ctx, lobby_id, world_id, Vec3::new(0.0, 0.5, 0.0), Vec3::new(2.0, 1.0, 8.0), 1);
    
    // Corner pillars (tall walls - block grenades)
    create_wall(ctx, lobby_id, world_id, Vec3::new(-12.0, 1.0, -12.0), Vec3::new(3.0, 2.0, 3.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(12.0, 1.0, -12.0), Vec3::new(3.0, 2.0, 3.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(-12.0, 1.0, 12.0), Vec3::new(3.0, 2.0, 3.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(12.0, 1.0, 12.0), Vec3::new(3.0, 2.0, 3.0), 2);
    
    // Side cover
    create_wall(ctx, lobby_id, world_id, Vec3::new(-18.0, 0.5, 0.0), Vec3::new(4.0, 1.0, 2.0), 1);
    create_wall(ctx, lobby_id, world_id, Vec3::new(18.0, 0.5, 0.0), Vec3::new(4.0, 1.0, 2.0), 1);
    create_wall(ctx, lobby_id, world_id, Vec3::new(0.0, 0.5, -18.0), Vec3::new(2.0, 1.0, 4.0), 1);
    create_wall(ctx, lobby_id, world_id, Vec3::new(0.0, 0.5, 18.0), Vec3::new(2.0, 1.0, 4.0), 1);
}

fn create_maze_map(ctx: &ReducerContext, lobby_id: u64, world_id: u64) {
    // Boundaries
    create_wall(ctx, lobby_id, world_id, Vec3::new(0.0, 1.0, -25.0), Vec3::new(50.0, 2.0, 1.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(0.0, 1.0, 25.0), Vec3::new(50.0, 2.0, 1.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(-25.0, 1.0, 0.0), Vec3::new(1.0, 2.0, 50.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(25.0, 1.0, 0.0), Vec3::new(1.0, 2.0, 50.0), 2);
    
    // Maze internal walls (mix of heights)
    // Horizontal walls
    create_wall(ctx, lobby_id, world_id, Vec3::new(-10.0, 0.5, -15.0), Vec3::new(20.0, 1.0, 1.0), 1);
    create_wall(ctx, lobby_id, world_id, Vec3::new(10.0, 1.0, -8.0), Vec3::new(15.0, 2.0, 1.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(-10.0, 0.5, 0.0), Vec3::new(15.0, 1.0, 1.0), 1);
    create_wall(ctx, lobby_id, world_id, Vec3::new(5.0, 1.0, 8.0), Vec3::new(20.0, 2.0, 1.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(-5.0, 0.5, 15.0), Vec3::new(15.0, 1.0, 1.0), 1);
    
    // Vertical walls
    create_wall(ctx, lobby_id, world_id, Vec3::new(-15.0, 1.0, -5.0), Vec3::new(1.0, 2.0, 15.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(-5.0, 0.5, 5.0), Vec3::new(1.0, 1.0, 10.0), 1);
    create_wall(ctx, lobby_id, world_id, Vec3::new(5.0, 1.0, -5.0), Vec3::new(1.0, 2.0, 10.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(15.0, 0.5, 5.0), Vec3::new(1.0, 1.0, 15.0), 1);
}

fn create_warehouse_map(ctx: &ReducerContext, lobby_id: u64, world_id: u64) {
    // Boundaries
    create_wall(ctx, lobby_id, world_id, Vec3::new(0.0, 1.0, -25.0), Vec3::new(50.0, 2.0, 1.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(0.0, 1.0, 25.0), Vec3::new(50.0, 2.0, 1.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(-25.0, 1.0, 0.0), Vec3::new(1.0, 2.0, 50.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(25.0, 1.0, 0.0), Vec3::new(1.0, 2.0, 50.0), 2);
    
    // Crate clusters (mix of heights for interesting gameplay)
    // Left side crates
    create_wall(ctx, lobby_id, world_id, Vec3::new(-18.0, 0.5, -15.0), Vec3::new(2.0, 1.0, 2.0), 1);
    create_wall(ctx, lobby_id, world_id, Vec3::new(-16.0, 1.0, -15.0), Vec3::new(2.0, 2.0, 2.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(-18.0, 0.5, -13.0), Vec3::new(2.0, 1.0, 2.0), 1);
    
    // Right side crates
    create_wall(ctx, lobby_id, world_id, Vec3::new(18.0, 0.5, 15.0), Vec3::new(2.0, 1.0, 2.0), 1);
    create_wall(ctx, lobby_id, world_id, Vec3::new(16.0, 1.0, 15.0), Vec3::new(2.0, 2.0, 2.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(18.0, 0.5, 13.0), Vec3::new(2.0, 1.0, 2.0), 1);
    
    // Center shelving units (long, tall)
    create_wall(ctx, lobby_id, world_id, Vec3::new(-8.0, 1.0, 0.0), Vec3::new(2.0, 2.0, 20.0), 2);
    create_wall(ctx, lobby_id, world_id, Vec3::new(8.0, 1.0, 0.0), Vec3::new(2.0, 2.0, 20.0), 2);
    
    // Cross walkways (low)
    create_wall(ctx, lobby_id, world_id, Vec3::new(0.0, 0.5, -10.0), Vec3::new(14.0, 1.0, 2.0), 1);
    create_wall(ctx, lobby_id, world_id, Vec3::new(0.0, 0.5, 10.0), Vec3::new(14.0, 1.0, 2.0), 1);
}

fn create_wall(
    ctx: &ReducerContext,
    lobby_id: u64,
    world_id: u64,
    pos: Vec3,
    size: Vec3,
    height: i32,
) {
    // Create static rigid body properties
    let rb_props = RigidBodyProperties::builder()
        .world_id(world_id)
        .mass(0.0) // Static objects have 0 mass
        .restitution(0.3)
        .build()
        .insert(ctx);
    
    // Create cuboid collider (size is half-extents)
    let half_extents = Vec3::new(size.x / 2.0, size.y / 2.0, size.z / 2.0);
    let collider = Collider::cuboid(world_id, half_extents).insert(ctx);
    
    // Create static rigid body
    let rb = RigidBody::builder()
        .world_id(world_id)
        .position_x(pos.x)
        .position_y(pos.y)
        .position_z(pos.z)
        .collider_id(collider.id)
        .properties_id(rb_props.id)
        .body_type(RigidBodyType::Static)
        .build()
        .insert(ctx);
    
    // Record wall for rendering/client sync
    ctx.db.map_wall().insert(MapWall {
        id: 0,
        lobby_id,
        rigid_body_id: rb.id,
        position_x: pos.x,
        position_y: pos.y,
        position_z: pos.z,
        size_x: size.x,
        size_y: size.y,
        size_z: size.z,
        height,
    });
}

// ============================================================================
// SPAWN POSITIONS
// ============================================================================

pub fn get_spawn_position(map_id: MapId, team: usize) -> Vec3 {
    match map_id {
        MapId::Arena => {
            let spawns = [
                Vec3::new(-20.0, 0.5, -20.0),
                Vec3::new(20.0, 0.5, 20.0),
                Vec3::new(-20.0, 0.5, 20.0),
                Vec3::new(20.0, 0.5, -20.0),
                Vec3::new(0.0, 0.5, -20.0),
                Vec3::new(0.0, 0.5, 20.0),
                Vec3::new(-20.0, 0.5, 0.0),
                Vec3::new(20.0, 0.5, 0.0),
            ];
            spawns[team % spawns.len()]
        }
        MapId::Maze => {
            let spawns = [
                Vec3::new(-22.0, 0.5, -22.0),
                Vec3::new(22.0, 0.5, 22.0),
                Vec3::new(-22.0, 0.5, 22.0),
                Vec3::new(22.0, 0.5, -22.0),
            ];
            spawns[team % spawns.len()]
        }
        MapId::Warehouse => {
            let spawns = [
                Vec3::new(-22.0, 0.5, 0.0),
                Vec3::new(22.0, 0.5, 0.0),
                Vec3::new(0.0, 0.5, -22.0),
                Vec3::new(0.0, 0.5, 22.0),
            ];
            spawns[team % spawns.len()]
        }
    }
}
