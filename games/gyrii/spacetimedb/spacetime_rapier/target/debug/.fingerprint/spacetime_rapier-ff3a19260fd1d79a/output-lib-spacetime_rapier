{"$message_type":"diagnostic","message":"the name `KinematicBody` is defined multiple times","code":{"code":"E0428","explanation":"A type or module has been defined more than once.\n\nErroneous code example:\n\n```compile_fail,E0428\nstruct Bar;\nstruct Bar; // error: duplicate definition of value `Bar`\n```\n\nPlease verify you didn't misspell the type/module's name or remove/rename the\nduplicated one. Example:\n\n```\nstruct Bar;\nstruct Bar2; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/engine/mod.rs","byte_start":820,"byte_end":865,"line_start":36,"line_end":36,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub type KinematicBody = (u64, (Vec3, Quat));","highlight_start":1,"highlight_end":46}],"label":"`KinematicBody` redefined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/engine/mod.rs","byte_start":749,"byte_end":793,"line_start":33,"line_end":33,"column_start":1,"column_end":45,"is_primary":false,"text":[{"text":"pub type KinematicBody = (u64, (Vec2, f32));","highlight_start":1,"highlight_end":45}],"label":"previous definition of the type `KinematicBody` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`KinematicBody` must be defined only once in the type namespace of this module","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0428]\u001b[0m\u001b[1m: the name `KinematicBody` is defined multiple times\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/engine/mod.rs:36:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub type KinematicBody = (u64, (Vec2, f32));\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m--------------------------------------------\u001b[0m \u001b[1m\u001b[94mprevious definition of the type `KinematicBody` here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m36\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub type KinematicBody = (u64, (Vec3, Quat));\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`KinematicBody` redefined here\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `KinematicBody` must be defined only once in the type namespace of this module\n\n"}
{"$message_type":"diagnostic","message":"the name `raycast_instant` is defined multiple times","code":{"code":"E0428","explanation":"A type or module has been defined more than once.\n\nErroneous code example:\n\n```compile_fail,E0428\nstruct Bar;\nstruct Bar; // error: duplicate definition of value `Bar`\n```\n\nPlease verify you didn't misspell the type/module's name or remove/rename the\nduplicated one. Example:\n\n```\nstruct Bar;\nstruct Bar2; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/queries/mod.rs","byte_start":727,"byte_end":948,"line_start":31,"line_end":40,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub fn raycast_instant(","highlight_start":1,"highlight_end":24},{"text":"    _ctx: &ReducerContext,","highlight_start":1,"highlight_end":27},{"text":"    _world: &PhysicsWorld,","highlight_start":1,"highlight_end":27},{"text":"    _origin: Vec2,","highlight_start":1,"highlight_end":19},{"text":"    _direction: Vec2,","highlight_start":1,"highlight_end":22},{"text":"    _max_distance: f32,","highlight_start":1,"highlight_end":24},{"text":") -> Vec<RayCastHit> {","highlight_start":1,"highlight_end":23},{"text":"    // TODO: Implement instant raycast","highlight_start":1,"highlight_end":39},{"text":"    Vec::new()","highlight_start":1,"highlight_end":15},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"`raycast_instant` redefined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/queries/mod.rs","byte_start":479,"byte_end":700,"line_start":19,"line_end":28,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"pub fn raycast_instant(","highlight_start":1,"highlight_end":24},{"text":"    _ctx: &ReducerContext,","highlight_start":1,"highlight_end":27},{"text":"    _world: &PhysicsWorld,","highlight_start":1,"highlight_end":27},{"text":"    _origin: Vec3,","highlight_start":1,"highlight_end":19},{"text":"    _direction: Vec3,","highlight_start":1,"highlight_end":22},{"text":"    _max_distance: f32,","highlight_start":1,"highlight_end":24},{"text":") -> Vec<RayCastHit> {","highlight_start":1,"highlight_end":23},{"text":"    // TODO: Implement instant raycast","highlight_start":1,"highlight_end":39},{"text":"    Vec::new()","highlight_start":1,"highlight_end":15},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"previous definition of the value `raycast_instant` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`raycast_instant` must be defined only once in the value namespace of this module","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0428]\u001b[0m\u001b[1m: the name `raycast_instant` is defined multiple times\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/queries/mod.rs:31:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub fn raycast_instant(\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _ctx: &ReducerContext,\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _world: &PhysicsWorld,\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _origin: Vec3,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Vec::new()\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_-\u001b[0m \u001b[1m\u001b[94mprevious definition of the value `raycast_instant` here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m pub fn raycast_instant(\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     _ctx: &ReducerContext,\n\u001b[1m\u001b[94m33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     _world: &PhysicsWorld,\n\u001b[1m\u001b[94m34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     _origin: Vec2,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     Vec::new()\n\u001b[1m\u001b[94m40\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91m`raycast_instant` redefined here\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `raycast_instant` must be defined only once in the value namespace of this module\n\n"}
{"$message_type":"diagnostic","message":"Cannot enable both 'dim2' and 'dim3' features simultaneously","code":null,"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":901,"byte_end":979,"line_start":32,"line_end":32,"column_start":1,"column_end":79,"is_primary":true,"text":[{"text":"compile_error!(\"Cannot enable both 'dim2' and 'dim3' features simultaneously\");","highlight_start":1,"highlight_end":79}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: Cannot enable both 'dim2' and 'dim3' features simultaneously\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:32:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m compile_error!(\"Cannot enable both 'dim2' and 'dim3' features simultaneously\");\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"field `position` is already declared","code":{"code":"E0124","explanation":"A struct was declared with two fields having the same name.\n\nErroneous code example:\n\n```compile_fail,E0124\nstruct Foo {\n    field1: i32,\n    field1: i32, // error: field is already declared\n}\n```\n\nPlease verify that the field names have been correctly spelled. Example:\n\n```\nstruct Foo {\n    field1: i32,\n    field2: i32, // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/engine/mod.rs","byte_start":554,"byte_end":572,"line_start":24,"line_end":24,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub position: Vec3,","highlight_start":5,"highlight_end":23}],"label":"field already declared","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/engine/mod.rs","byte_start":501,"byte_end":519,"line_start":22,"line_end":22,"column_start":5,"column_end":23,"is_primary":false,"text":[{"text":"    pub position: Vec2,","highlight_start":5,"highlight_end":23}],"label":"`position` first declared here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0124]\u001b[0m\u001b[1m: field `position` is already declared\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/engine/mod.rs:24:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub position: Vec2,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94m`position` first declared here\u001b[0m\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[cfg(feature = \"dim3\")]\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub position: Vec3,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mfield already declared\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"field `rotation` is already declared","code":{"code":"E0124","explanation":"A struct was declared with two fields having the same name.\n\nErroneous code example:\n\n```compile_fail,E0124\nstruct Foo {\n    field1: i32,\n    field1: i32, // error: field is already declared\n}\n```\n\nPlease verify that the field names have been correctly spelled. Example:\n\n```\nstruct Foo {\n    field1: i32,\n    field2: i32, // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/engine/mod.rs","byte_start":659,"byte_end":677,"line_start":28,"line_end":28,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    pub rotation: Quat,","highlight_start":5,"highlight_end":23}],"label":"field already declared","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/engine/mod.rs","byte_start":607,"byte_end":624,"line_start":26,"line_end":26,"column_start":5,"column_end":22,"is_primary":false,"text":[{"text":"    pub rotation: f32,","highlight_start":5,"highlight_end":22}],"label":"`rotation` first declared here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0124]\u001b[0m\u001b[1m: field `rotation` is already declared\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/engine/mod.rs:28:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub rotation: f32,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-----------------\u001b[0m \u001b[1m\u001b[94m`rotation` first declared here\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[cfg(feature = \"dim3\")]\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub rotation: Quat,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mfield already declared\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"duplicate definitions with name `gravity_vector`","code":{"code":"E0592","explanation":"This error occurs when you defined methods or associated functions with same\nname.\n\nErroneous code example:\n\n```compile_fail,E0592\nstruct Foo;\n\nimpl Foo {\n    fn bar() {} // previous definition here\n}\n\nimpl Foo {\n    fn bar() {} // duplicate definition here\n}\n```\n\nA similar error is E0201. The difference is whether there is one declaration\nblock or not. To avoid this error, you must give each `fn` a unique name.\n\n```\nstruct Foo;\n\nimpl Foo {\n    fn bar() {}\n}\n\nimpl Foo {\n    fn baz() {} // define with different name\n}\n```\n"},"level":"error","spans":[{"file_name":"src/tables/physics_world.rs","byte_start":2522,"byte_end":2576,"line_start":88,"line_end":88,"column_start":5,"column_end":59,"is_primary":true,"text":[{"text":"    pub fn gravity_vector(&self) -> nalgebra::Vector2<f32> {","highlight_start":5,"highlight_end":59}],"label":"duplicate definitions for `gravity_vector`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/tables/physics_world.rs","byte_start":2296,"byte_end":2350,"line_start":82,"line_end":82,"column_start":5,"column_end":59,"is_primary":false,"text":[{"text":"    pub fn gravity_vector(&self) -> nalgebra::Vector3<f32> {","highlight_start":5,"highlight_end":59}],"label":"other definition for `gravity_vector`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0592]\u001b[0m\u001b[1m: duplicate definitions with name `gravity_vector`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/tables/physics_world.rs:88:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn gravity_vector(&self) -> nalgebra::Vector3<f32> {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m------------------------------------------------------\u001b[0m \u001b[1m\u001b[94mother definition for `gravity_vector`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m88\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn gravity_vector(&self) -> nalgebra::Vector2<f32> {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mduplicate definitions for `gravity_vector`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/engine/world_2d.rs","byte_start":7430,"byte_end":7438,"line_start":192,"line_end":192,"column_start":9,"column_end":17,"is_primary":true,"text":[{"text":"        &gravity,","highlight_start":9,"highlight_end":17}],"label":"expected `2`, found `3`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/engine/world_2d.rs","byte_start":7416,"byte_end":7420,"line_start":191,"line_end":191,"column_start":22,"column_end":26,"is_primary":false,"text":[{"text":"    physics_pipeline.step(","highlight_start":22,"highlight_end":26}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&Matrix<_, Const<2>, _, ArrayStorage<_, 2, _>>`\n   found reference `&Matrix<_, Const<3>, _, ArrayStorage<_, 3, _>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/sterlinglong/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rapier2d-0.22.0/src/pipeline/physics_pipeline.rs","byte_start":15713,"byte_end":15717,"line_start":408,"line_end":408,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"    pub fn step(","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/engine/world_2d.rs:192:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m191\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     physics_pipeline.step(\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94marguments to this method are incorrect\u001b[0m\n\u001b[1m\u001b[94m192\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         &gravity,\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `2`, found `3`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&Matrix<_, Const<\u001b[1m\u001b[35m2\u001b[0m>, _, ArrayStorage<_, \u001b[1m\u001b[35m2\u001b[0m, _>>`\n               found reference `&Matrix<_, Const<\u001b[1m\u001b[35m3\u001b[0m>, _, ArrayStorage<_, \u001b[1m\u001b[35m3\u001b[0m, _>>`\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/sterlinglong/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rapier2d-0.22.0/src/pipeline/physics_pipeline.rs:408:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m408\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn step(\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"a value of type `HashMap<u64, (Vec3, Quat)>` cannot be built from an iterator over elements of type `(u64, (Vec2, f32))`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/engine/world_3d.rs","byte_start":1122,"byte_end":1129,"line_start":37,"line_end":37,"column_start":10,"column_end":17,"is_primary":true,"text":[{"text":"        .collect();","highlight_start":10,"highlight_end":17}],"label":"value of type `HashMap<u64, (Vec3, Quat)>` cannot be built from `std::iter::Iterator<Item=(u64, (Vec2, f32))>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `FromIterator<(_, (Vec2, f32))>` is not implemented for `HashMap<u64, (Vec3, Quat)>`\nbut trait `FromIterator<(_, (Vec3, Quat))>` is implemented for it","code":null,"level":"help","spans":[{"file_name":"/rustc/842bd5be253e17831e318fdbd9d01d716557cc75/library/std/src/collections/hash/map.rs","byte_start":88098,"byte_end":88207,"line_start":2910,"line_end":2913,"column_start":1,"column_end":30,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for that trait implementation, expected `Vec3`, found `Vec2`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the method call chain might not have had the expected associated types","code":null,"level":"note","spans":[{"file_name":"src/engine/world_3d.rs","byte_start":1072,"byte_end":1112,"line_start":36,"line_end":36,"column_start":10,"column_end":50,"is_primary":false,"text":[{"text":"        .map(|(id, (pos, rot))| (id, (pos, rot)))","highlight_start":10,"highlight_end":50}],"label":"`Iterator::Item` remains `(u64, (Vec2, f32))` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/engine/world_3d.rs","byte_start":903,"byte_end":938,"line_start":32,"line_end":32,"column_start":25,"column_end":60,"is_primary":true,"text":[{"text":"    kinematic_entities: impl Iterator<Item = KinematicBody>,","highlight_start":25,"highlight_end":60}],"label":"`Iterator::Item` is `(u64, (Vec2, f32))` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `collect`","code":null,"level":"note","spans":[{"file_name":"/rustc/842bd5be253e17831e318fdbd9d01d716557cc75/library/core/src/iter/traits/iterator.rs","byte_start":68130,"byte_end":68211,"line_start":2022,"line_end":2024,"column_start":5,"column_end":21,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: a value of type `HashMap<u64, (Vec3, Quat)>` cannot be built from an iterator over elements of type `(u64, (Vec2, f32))`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/engine/world_3d.rs:37:10\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .collect();\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mvalue of type `HashMap<u64, (Vec3, Quat)>` cannot be built from `std::iter::Iterator<Item=(u64, (Vec2, f32))>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `FromIterator<(_, (\u001b[1m\u001b[35mVec2\u001b[0m, \u001b[1m\u001b[35mf32\u001b[0m))>` \u001b[1m\u001b[35mis not\u001b[0m implemented for `HashMap<u64, (Vec3, Quat)>`\n      but trait `FromIterator<(_, (\u001b[1m\u001b[35mVec3\u001b[0m, \u001b[1m\u001b[35mQuat\u001b[0m))>` \u001b[1m\u001b[35mis\u001b[0m implemented for it\n  \u001b[1m\u001b[94m--> \u001b[0m/rustc/842bd5be253e17831e318fdbd9d01d716557cc75/library/std/src/collections/hash/map.rs:2910:0\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: for that trait implementation, expected `\u001b[1m\u001b[35mVec3\u001b[0m`, found `\u001b[1m\u001b[35mVec2\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: the method call chain might not have had the expected associated types\n  \u001b[1m\u001b[94m--> \u001b[0msrc/engine/world_3d.rs:32:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     kinematic_entities: impl Iterator<Item = KinematicBody>,\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92m`Iterator::Item` is `(u64, (Vec2, f32))` here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m36\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .map(|(id, (pos, rot))| (id, (pos, rot)))\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m----------------------------------------\u001b[0m \u001b[1m\u001b[94m`Iterator::Item` remains `(u64, (Vec2, f32))` here\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `collect`\n  \u001b[1m\u001b[94m--> \u001b[0m/rustc/842bd5be253e17831e318fdbd9d01d716557cc75/library/core/src/iter/traits/iterator.rs:2022:4\n\n"}
{"$message_type":"diagnostic","message":"use of moved value: `kinematic_entities`","code":{"code":"E0382","explanation":"A variable was used after its contents have been moved elsewhere.\n\nErroneous code example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`. Implicit\ncloning is more convenient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the\n[Understanding Ownership][understanding-ownership] chapter in the Book.\n\n[understanding-ownership]: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n"},"level":"error","spans":[{"file_name":"src/engine/mod.rs","byte_start":1412,"byte_end":1430,"line_start":54,"line_end":54,"column_start":41,"column_end":59,"is_primary":false,"text":[{"text":"    world_2d::step_world_2d(ctx, world, kinematic_entities);","highlight_start":41,"highlight_end":59}],"label":"value moved here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/engine/mod.rs","byte_start":1503,"byte_end":1521,"line_start":57,"line_end":57,"column_start":41,"column_end":59,"is_primary":true,"text":[{"text":"    world_3d::step_world_3d(ctx, world, kinematic_entities);","highlight_start":41,"highlight_end":59}],"label":"value used here after move","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/engine/mod.rs","byte_start":1282,"byte_end":1300,"line_start":51,"line_end":51,"column_start":5,"column_end":23,"is_primary":false,"text":[{"text":"    kinematic_entities: impl Iterator<Item = KinematicBody>,","highlight_start":5,"highlight_end":23}],"label":"move occurs because `kinematic_entities` has type `impl Iterator<Item = KinematicBody>`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if `impl Iterator<Item = KinematicBody>` implemented `Clone`, you could clone the value","code":null,"level":"help","spans":[{"file_name":"src/engine/mod.rs","byte_start":1302,"byte_end":1337,"line_start":51,"line_end":51,"column_start":25,"column_end":60,"is_primary":true,"text":[{"text":"    kinematic_entities: impl Iterator<Item = KinematicBody>,","highlight_start":25,"highlight_end":60}],"label":"consider constraining this type parameter with `Clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/engine/mod.rs","byte_start":1412,"byte_end":1430,"line_start":54,"line_end":54,"column_start":41,"column_end":59,"is_primary":false,"text":[{"text":"    world_2d::step_world_2d(ctx, world, kinematic_entities);","highlight_start":41,"highlight_end":59}],"label":"you could clone this value","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider mutably borrowing `kinematic_entities`","code":null,"level":"help","spans":[{"file_name":"src/engine/mod.rs","byte_start":1412,"byte_end":1412,"line_start":54,"line_end":54,"column_start":41,"column_end":41,"is_primary":true,"text":[{"text":"    world_2d::step_world_2d(ctx, world, kinematic_entities);","highlight_start":41,"highlight_end":41}],"label":null,"suggested_replacement":"&mut ","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider restricting opaque type `impl Iterator<Item = KinematicBody>` with trait `Copy`","code":null,"level":"help","spans":[{"file_name":"src/engine/mod.rs","byte_start":1337,"byte_end":1337,"line_start":51,"line_end":51,"column_start":60,"column_end":60,"is_primary":true,"text":[{"text":"    kinematic_entities: impl Iterator<Item = KinematicBody>,","highlight_start":60,"highlight_end":60}],"label":null,"suggested_replacement":" + Copy","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0382]\u001b[0m\u001b[1m: use of moved value: `kinematic_entities`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/engine/mod.rs:57:41\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     kinematic_entities: impl Iterator<Item = KinematicBody>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mmove occurs because `kinematic_entities` has type `impl Iterator<Item = KinematicBody>`, which does not implement the `Copy` trait\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     world_2d::step_world_2d(ctx, world, kinematic_entities);\n   \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mvalue moved here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     world_3d::step_world_3d(ctx, world, kinematic_entities);\n   \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvalue used here after move\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if `impl Iterator<Item = KinematicBody>` implemented `Clone`, you could clone the value\n  \u001b[1m\u001b[94m--> \u001b[0msrc/engine/mod.rs:51:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     kinematic_entities: impl Iterator<Item = KinematicBody>,\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[96mconsider constraining this type parameter with `Clone`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     world_2d::step_world_2d(ctx, world, kinematic_entities);\n   \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94myou could clone this value\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider mutably borrowing `kinematic_entities`\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    world_2d::step_world_2d(ctx, world, \u001b[92m&mut \u001b[0mkinematic_entities);\n   \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[92m++++\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider restricting opaque type `impl Iterator<Item = KinematicBody>` with trait `Copy`\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    kinematic_entities: impl Iterator<Item = KinematicBody>\u001b[92m + Copy\u001b[0m,\n   \u001b[1m\u001b[94m|\u001b[0m                                                             \u001b[92m++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 9 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 9 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0124, E0277, E0308, E0382, E0428, E0592.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0124, E0277, E0308, E0382, E0428, E0592.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0124`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0124`.\u001b[0m\n"}
